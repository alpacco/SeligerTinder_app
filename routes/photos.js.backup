// routes/photos.js
const express = require('express');
const multer = require('multer');
const fs = require('fs');
const path = require('path');
const { bot } = require('../bot');
const vision = require('@google-cloud/vision');
const sharp = require('sharp');
const visionKeyPath = path.join(__dirname, '../Google Vision/vision-key.json');
let visionClient = null;
if (fs.existsSync(visionKeyPath)) {
  try {
    visionClient = new vision.ImageAnnotatorClient({ keyFilename: visionKeyPath });
    console.log('‚úÖ Google Vision API –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω —É—Å–ø–µ—à–Ω–æ');
    console.log('üîç [Vision] –ì–æ—Ç–æ–≤ –∫ –ø—Ä–æ–≤–µ—Ä–∫–µ –ª–∏—Ü –∏ –º–µ–º–æ–≤/—Ñ–µ–π–∫–æ–≤');
  } catch (error) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ Google Vision API:', error.message);
    visionClient = null;
  }
} else {
  console.warn('‚ö†Ô∏è –§–∞–π–ª Google Vision –∫–ª—é—á–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω:', visionKeyPath);
  console.log('üîç [Vision] Google Vision API –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω - –ø—Ä–æ–≤–µ—Ä–∫–∞ –ª–∏—Ü –∏ –º–µ–º–æ–≤/—Ñ–µ–π–∫–æ–≤ –æ—Ç–∫–ª—é—á–µ–Ω–∞');
  visionClient = null;
}
// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ HEIC –≤ JPEG
async function convertHeicToJpeg(buffer) {
  try {
    const jpegBuffer = await sharp(buffer)
      .jpeg({ quality: 90 })
      .toBuffer();
    console.log('üîß [Image] HEIC —É—Å–ø–µ—à–Ω–æ –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞–Ω –≤ JPEG');
    return jpegBuffer;
  } catch (error) {
    console.error('‚ùå [Image] –û—à–∏–±–∫–∞ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ HEIC:', error);
    return buffer; // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π –±—É—Ñ–µ—Ä –µ—Å–ª–∏ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –Ω–µ —É–¥–∞–ª–∞—Å—å
  }
}

async function faceDetector(imagePath) {
  console.log(`üîç [Vision] –ù–∞—á–∏–Ω–∞–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É –ª–∏—Ü–∞ —á–µ—Ä–µ–∑ Google Vision API...`);
  console.log(`üîç [Vision] –ü—É—Ç—å –∫ —Ñ–∞–π–ª—É: ${imagePath}`);
  
  try {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Ñ–∞–π–ª —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
    if (!fs.existsSync(imagePath)) {
      console.error(`‚ùå [Vision] –§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω: ${imagePath}`);
      return false;
    }
    
    // –ü–æ–ª—É—á–∞–µ–º —Ä–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞
    const stats = fs.statSync(imagePath);
    console.log(`üîç [Vision] –†–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞: ${stats.size} –±–∞–π—Ç`);
    
    const [result] = await visionClient.faceDetection(imagePath);
    const faces = result.faceAnnotations;
    const hasFace = Array.isArray(faces) && faces.length > 0;
    
    console.log(`üîç [Vision] –†–µ–∑—É–ª—å—Ç–∞—Ç –ø—Ä–æ–≤–µ—Ä–∫–∏ –ª–∏—Ü–∞: ${hasFace ? '–õ–ò–¶–û –ù–ê–ô–î–ï–ù–û' : '–õ–ò–¶–û –ù–ï –ù–ê–ô–î–ï–ù–û'} (–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ª–∏—Ü: ${faces?.length || 0})`);
    
    if (faces && faces.length > 0) {
      console.log(`üîç [Vision] –î–µ—Ç–∞–ª–∏ –Ω–∞–π–¥–µ–Ω–Ω—ã—Ö –ª–∏—Ü:`);
      faces.forEach((face, index) => {
        console.log(`  –õ–∏—Ü–æ ${index + 1}: confidence=${face.detectionConfidence}, joy=${face.joyLikelihood}, sorrow=${face.sorrowLikelihood}`);
      });
    }
    
    return hasFace;
  } catch (error) {
    console.error('‚ùå [Vision] –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –ª–∏—Ü–∞:', error.message);
    console.error('‚ùå [Vision] –ü–æ–ª–Ω–∞—è –æ—à–∏–±–∫–∞:', error);
    return false;
  }
}

// –ù–æ–≤—ã–π –≤–∞—Ä–∏–∞–Ω—Ç –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –±—É—Ñ–µ—Ä–æ–º
async function faceDetectorBuffer(imageBuffer) {
  if (!visionClient) {
    console.log('üîç [Vision] –ö–ª–∏–µ–Ω—Ç –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É –ª–∏—Ü–∞');
    return false;
  }
  console.log('üîç [Vision] –ù–∞—á–∏–Ω–∞–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É –ª–∏—Ü–∞ —á–µ—Ä–µ–∑ Google Vision API (–±—É—Ñ–µ—Ä)...');
  try {
    // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º HEIC –≤ JPEG –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
    let processedBuffer = imageBuffer;
    if (imageBuffer.length > 0) {
      try {
        processedBuffer = await convertHeicToJpeg(imageBuffer);
      } catch (error) {
        console.log('üîç [Vision] –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è HEIC –Ω–µ —É–¥–∞–ª–∞—Å—å, –∏—Å–ø–æ–ª—å–∑—É–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π –±—É—Ñ–µ—Ä');
      }
    }
    
    const [result] = await visionClient.faceDetection({
      image: { content: processedBuffer.toString('base64') }
    });
    const faces = result.faceAnnotations;
    const hasFace = Array.isArray(faces) && faces.length > 0;
    console.log(`üîç [Vision] –†–µ–∑—É–ª—å—Ç–∞—Ç –ø—Ä–æ–≤–µ—Ä–∫–∏ –ª–∏—Ü–∞ (–±—É—Ñ–µ—Ä): ${hasFace ? '–õ–ò–¶–û –ù–ê–ô–î–ï–ù–û' : '–õ–ò–¶–û –ù–ï –ù–ê–ô–î–ï–ù–û'} (–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ª–∏—Ü: ${faces?.length || 0})`);
    return hasFace;
  } catch (error) {
    console.error('‚ùå [Vision] –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –ª–∏—Ü–∞ (–±—É—Ñ–µ—Ä):', error.message);
    return false;
  }
}
global.faceDetectorBuffer = faceDetectorBuffer;

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –Ω–∞–ª–∏—á–∏—è –ª–∏—Ü–∞ –Ω–∞ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏ —á–µ—Ä–µ–∑ Google Vision
async function checkFaceInPhoto(visionClient, imageBuffer) {
  console.log(`üîç [Vision] –ù–∞—á–∏–Ω–∞–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É –Ω–∞–ª–∏—á–∏—è –ª–∏—Ü–∞ –Ω–∞ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏`);
  
  if (!visionClient) {
    console.log('üîç [Vision] –ö–ª–∏–µ–Ω—Ç –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É –ª–∏—Ü–∞');
    return { success: false, error: '–°–µ—Ä–≤–∏—Å –ø—Ä–æ–≤–µ—Ä–∫–∏ –ª–∏—Ü–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω' };
  }
  
  try {
    console.log('üîç [Vision] –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ñ–æ—Ç–æ –≤ Google Vision API –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –ª–∏—Ü–∞...');
    
    // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º HEIC –≤ JPEG –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
    let processedBuffer = imageBuffer;
    if (imageBuffer.length > 0) {
      try {
        processedBuffer = await convertHeicToJpeg(imageBuffer);
      } catch (error) {
        console.log('üîç [Vision] –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è HEIC –Ω–µ —É–¥–∞–ª–∞—Å—å, –∏—Å–ø–æ–ª—å–∑—É–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π –±—É—Ñ–µ—Ä');
      }
    }
    
    const [result] = await visionClient.faceDetection({
      image: { content: processedBuffer.toString('base64') }
    });

    const faces = result.faceAnnotations;
    console.log(`üîç [Vision] –ü–æ–ª—É—á–µ–Ω –æ—Ç–≤–µ—Ç –æ—Ç Vision API, –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ª–∏—Ü: ${faces?.length || 0}`);
    
    if (!faces || faces.length === 0) {
      console.log('üîç [Vision] –õ–∏—Ü–æ –Ω–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–æ –Ω–∞ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏');
      return { success: false, error: '–õ–∏—Ü–æ –Ω–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–æ –Ω–∞ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏' };
    }

    console.log(`üîç [Vision] ‚úÖ –õ–∏—Ü–æ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–æ –Ω–∞ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏ (–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ª–∏—Ü: ${faces.length})`);
    return { 
      success: true, 
      faceCount: faces.length 
    };
    
  } catch (error) {
    console.error('‚ùå [Vision] –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –ª–∏—Ü–∞ —á–µ—Ä–µ–∑ Vision API:', error);
    return { 
      success: false, 
      error: '–û—à–∏–±–∫–∞ –ø—Ä–∏ –∞–Ω–∞–ª–∏–∑–µ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.' 
    };
  }
}

// --- –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –º–µ–º–æ–≤ –∏ —Ñ–µ–π–∫–æ–≤—ã—Ö –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π —á–µ—Ä–µ–∑ Vision ---
async function isMemeOrFake(visionClient, imageBuffer) {
  console.log('üîç [Vision] –ù–∞—á–∏–Ω–∞–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É –Ω–∞ –º–µ–º—ã/—Ñ–µ–π–∫–∏ —á–µ—Ä–µ–∑ Google Vision API...');
  
  if (!visionClient) {
    console.log('üîç [Vision] –ö–ª–∏–µ–Ω—Ç –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É –º–µ–º–æ–≤/—Ñ–µ–π–∫–æ–≤');
    return { isMeme: false };
  }
  
  try {
    // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º HEIC –≤ JPEG –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
    let processedBuffer = imageBuffer;
    if (imageBuffer.length > 0) {
      try {
        processedBuffer = await convertHeicToJpeg(imageBuffer);
      } catch (error) {
        console.log('üîç [Vision] –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è HEIC –Ω–µ —É–¥–∞–ª–∞—Å—å, –∏—Å–ø–æ–ª—å–∑—É–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π –±—É—Ñ–µ—Ä');
      }
    }
    
    // SafeSearch
    console.log('üîç [Vision] –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å SafeSearch –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –Ω–∞ —Ñ–µ–π–∫–∏...');
    const [safeResult] = await visionClient.safeSearchDetection({ 
      image: { content: processedBuffer.toString('base64') } 
    });
    const safe = safeResult.safeSearchAnnotation || {};
    const spoof = safe.spoof || 'UNKNOWN';
    const spoofMap = { 
      'VERY_LIKELY': 0.9, 
      'LIKELY': 0.7, 
      'POSSIBLE': 0.5, 
      'UNLIKELY': 0.3, 
      'VERY_UNLIKELY': 0.1, 
      'UNKNOWN': 0.5 
    };
    const spoofScore = spoofMap[spoof] || 0.5;
    
    console.log(`üîç [Vision] SafeSearch —Ä–µ–∑—É–ª—å—Ç–∞—Ç: spoof=${spoof} (score=${spoofScore})`);
    
    if (spoofScore >= 0.7) {
      console.log(`üîç [Vision] –û–®–ò–ë–ö–ê: –û–±–Ω–∞—Ä—É–∂–µ–Ω —Ñ–µ–π–∫/–º–µ–º —á–µ—Ä–µ–∑ SafeSearch (${spoof})`);
      return { isMeme: true, reason: `SafeSearch spoofLikelihood=${spoof}` };
    }
    
    // Web Detection
    console.log('üîç [Vision] –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å Web Detection –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –Ω–∞ –º–µ–º—ã...');
    const [webResult] = await visionClient.webDetection({ 
      image: { content: processedBuffer.toString('base64') } 
    });
    const web = webResult.webDetection || {};
    
    console.log(`üîç [Vision] Web Detection —Ä–µ–∑—É–ª—å—Ç–∞—Ç:`, {
      bestGuessLabels: web.bestGuessLabels?.length || 0,
      webEntities: web.webEntities?.length || 0
    });
    
    if (web.bestGuessLabels && web.bestGuessLabels.length) {
      const label = web.bestGuessLabels[0].label || '';
      console.log(`üîç [Vision] –õ—É—á—à–∏–π –ª–µ–π–±–ª: "${label}"`);
      // –ë–æ–ª–µ–µ –º—è–≥–∫–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ - —Ç–æ–ª—å–∫–æ —è–≤–Ω—ã–µ –º–µ–º—ã
      if (/meme|deepfake|ai generated|artificial intelligence|generated|screenshot|screen capture/i.test(label)) {
        console.log(`üîç [Vision] –û–®–ò–ë–ö–ê: –û–±–Ω–∞—Ä—É–∂–µ–Ω –º–µ–º/—Ñ–µ–π–∫ —á–µ—Ä–µ–∑ Web Detection (label: ${label})`);
        return { isMeme: true, reason: `WebDetection label: ${label}` };
      }
    }
    
    if (web.webEntities && web.webEntities.length) {
      console.log(`üîç [Vision] –ü—Ä–æ–≤–µ—Ä—è–µ–º ${web.webEntities.length} –≤–µ–±-—Å—É—â–Ω–æ—Å—Ç–µ–π...`);
      for (const ent of web.webEntities) {
        if (ent.description && /meme|deepfake|ai generated|artificial intelligence|generated|screenshot|screen capture/i.test(ent.description)) {
          console.log(`üîç [Vision] –û–®–ò–ë–ö–ê: –û–±–Ω–∞—Ä—É–∂–µ–Ω –º–µ–º/—Ñ–µ–π–∫ —á–µ—Ä–µ–∑ Web Detection (entity: ${ent.description})`);
          return { isMeme: true, reason: `WebDetection entity: ${ent.description}` };
        }
      }
    }
    
    console.log('üîç [Vision] ‚úÖ –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –º–µ–º—ã/—Ñ–µ–π–∫–∏ –ø—Ä–æ–π–¥–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ');
    return { isMeme: false };
    
  } catch (err) {
    console.error('‚ùå [Vision] –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –º–µ–º–æ–≤/—Ñ–µ–π–∫–æ–≤:', err);
    return { isMeme: false };
  }
}

const FACEPP_API_KEY = process.env.FACEPP_API_KEY;
const FACEPP_API_SECRET = process.env.FACEPP_API_SECRET;

// –õ–æ–≥–∏ –¥–ª—è Face++ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏
if (FACEPP_API_KEY && FACEPP_API_SECRET) {
  console.log('üîç [Face++] API –∫–ª—é—á–∏ –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã, –≥–æ—Ç–æ–≤ –∫ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—é –ø–æ–ª–∞');
} else {
  console.log('üîç [Face++] API –∫–ª—é—á–∏ –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã, –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø–æ–ª–∞ –æ—Ç–∫–ª—é—á–µ–Ω–æ');
}

async function detectGenderFacePlusPlus(imageBuffer, apiKey, apiSecret) {
  console.log('üîç [Face++] –ù–∞—á–∏–Ω–∞–µ–º –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø–æ–ª–∞ —á–µ—Ä–µ–∑ Face++ API...');
  
  if (!apiKey || !apiSecret) {
    console.log('üîç [Face++] API –∫–ª—é—á–∏ –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø–æ–ª–∞');
    return { success: false, error: '–°–µ—Ä–≤–∏—Å –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –ø–æ–ª–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω' };
  }
  
  try {
    // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º HEIC –≤ JPEG –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
    let processedBuffer = imageBuffer;
    if (imageBuffer.length > 0) {
      try {
        processedBuffer = await convertHeicToJpeg(imageBuffer);
      } catch (error) {
        console.log('üîç [Face++] –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è HEIC –Ω–µ —É–¥–∞–ª–∞—Å—å, –∏—Å–ø–æ–ª—å–∑—É–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π –±—É—Ñ–µ—Ä');
      }
    }
    
    const base64 = processedBuffer.toString('base64');
    console.log(`üîç [Face++] –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ (—Ä–∞–∑–º–µ—Ä –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: ${processedBuffer.length} –±–∞–π—Ç)`);
    
    const formData = new URLSearchParams();
    formData.append('api_key', apiKey);
    formData.append('api_secret', apiSecret);
    formData.append('image_base64', base64);
    formData.append('return_attributes', 'gender');
    
    console.log('üîç [Face++] –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å –≤ Face++ API...');
    const resp = await fetch('https://api-us.faceplusplus.com/facepp/v3/detect', {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: formData.toString()
    });
    
    console.log(`üîç [Face++] –ü–æ–ª—É—á–µ–Ω –æ—Ç–≤–µ—Ç –æ—Ç Face++ API, —Å—Ç–∞—Ç—É—Å: ${resp.status}`);
    
    if (!resp.ok) {
      const errorText = await resp.text();
      console.error(`üîç [Face++] –û—à–∏–±–∫–∞ Face++ API: ${resp.status} - ${errorText}`);
      throw new Error(`Face++ API error: ${resp.statusText}`);
    }
    
    const data = await resp.json();
    console.log(`üîç [Face++] –û—Ç–≤–µ—Ç Face++ API:`, {
      face_num: data.face_num,
      faces_count: data.faces?.length || 0,
      error_message: data.error_message
    });
    
    if (!data.faces || data.faces.length === 0) {
      console.log('üîç [Face++] –õ–∏—Ü–æ –Ω–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–æ –Ω–∞ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏');
      return { success: false, error: '–õ–∏—Ü–æ –Ω–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–æ' };
    }
    
    const face = data.faces[0];
    const gender = face.attributes.gender.value; // 'Male' –∏–ª–∏ 'Female'
    const confidence = face.attributes.gender.confidence;
    
    console.log(`üîç [Face++] ‚úÖ –û–ø—Ä–µ–¥–µ–ª–µ–Ω –ø–æ–ª: ${gender} (—É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å: ${confidence}%)`);
    return { 
      success: true, 
      gender,
      confidence: confidence / 100 // –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ –¥–µ—Å—è—Ç–∏—á–Ω—É—é –¥—Ä–æ–±—å
    };
    
  } catch (error) {
    console.error('‚ùå [Face++] –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–∏ –ø–æ–ª–∞ —á–µ—Ä–µ–∑ Face++ API:', error);
    return { 
      success: false, 
      error: '–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–∏ –ø–æ–ª–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.' 
    };
  }
}

function photosRouter(db, logger, IMG_DIR, BOT_TOKEN, visionClient) {
  const router = express.Router();

  // –ü–∞—Ä—Å–∏–º JSON —Ç–µ–ª–∞
  router.use(express.json());

  // –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º multer –¥–ª—è multipart/form-data
  // –í CommonJS __dirname —É–∂–µ –¥–æ—Å—Ç—É–ø–µ–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ–º –µ–≥–æ –Ω–∞–ø—Ä—è–º—É—é
  const upload = multer({ dest: path.join(__dirname, '../uploads') });
  // Using native fetch API (available in Node.js 18+)

  /**
   * multipart upload
   * POST /api/photos/upload  –∏  POST /api/photos/uploadPhoto
   * –ø–æ–ª—è: file (—Ñ–∞–π–ª), userId
   */
  // --- –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ñ–æ—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ---
  // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ–ª—å–∫–æ Face++ –¥–ª—è –ø–æ–ª–∞, Vision ‚Äî —Ç–æ–ª—å–∫–æ –¥–ª—è –ª–∏—Ü–∞ –∏ –º–µ–º–æ–≤/—Ñ–µ–π–∫–æ–≤
  router.post(['/upload', '/uploadPhoto'], upload.single('file'), async (req, res) => {
    try {
      const { userId } = req.body;
      console.log(`[uploadPhoto] userId=${userId}, temp file: ${req.file?.path}`);
      if (!userId || !req.file) {
        if (req.file) fs.unlinkSync(req.file.path);
        return res.status(400).json({ success: false, error: 'userId –∏ file –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã' });
      }
      const tmpPath = req.file.path;
      const buffer = fs.readFileSync(tmpPath);
      fs.unlinkSync(tmpPath);
      // –ü–æ–ª—É—á–∞–µ–º –ø–æ–ª –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ –ë–î –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏
      const userRow = await new Promise((resolve, reject) =>
        db.get('SELECT gender FROM users WHERE userId = ?', [userId], (err, r) => err ? reject(err) : resolve(r))
      );
      if (!userRow || !userRow.gender) {
        return res.status(400).json({ success: false, error: '–ü–æ–ª –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –Ω–µ —É–∫–∞–∑–∞–Ω. –°–Ω–∞—á–∞–ª–∞ —É–∫–∞–∂–∏—Ç–µ —Å–≤–æ–π –ø–æ–ª.' });
      }
      // 1. –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è –ª–∏—Ü–∞ —á–µ—Ä–µ–∑ Vision
      let hasFace = true;
      if (visionClient) {
        try {
          hasFace = await faceDetector(tmpPath);
          console.log(`[uploadPhoto] Vision: –ª–∏—Ü–æ –Ω–∞–π–¥–µ–Ω–æ: ${hasFace}`);
        } catch (err) {
          console.error(`[uploadPhoto] Vision: –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–∏—Å–∫–µ –ª–∏—Ü–∞:`, err);
          return res.status(500).json({ success: false, error: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–∏—Å–∞ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è –ª–∏—Ü' });
        }
      } else {
        console.warn('[uploadPhoto] Vision –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç, –ª–∏—Ü–æ –Ω–µ –ø—Ä–æ–≤–µ—Ä—è–µ—Ç—Å—è!');
      }
      if (!hasFace) {
        console.warn('[uploadPhoto] –õ–∏—Ü–æ –Ω–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–æ, —Ñ–∞–π–ª –Ω–µ –¥–æ–±–∞–≤–ª–µ–Ω');
        return res.status(400).json({ success: false, error: '–õ–∏—Ü–æ –Ω–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–æ. –ó–∞–≥—Ä—É–∑–∏—Ç–µ –¥—Ä—É–≥–æ–µ —Ñ–æ—Ç–æ.', needPhoto: 1 });
      }
      // 2. –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –º–µ–º—ã/—Ñ–µ–π–∫–∏ —á–µ—Ä–µ–∑ Vision
      if (visionClient) {
        const memeCheck = await isMemeOrFake(visionClient, buffer);
        console.log(`[uploadPhoto] Vision: meme/fake check:`, memeCheck);
        if (memeCheck.isMeme) {
          console.warn(`[uploadPhoto] Vision: –º–µ–º/—Ñ–µ–π–∫ (${memeCheck.reason})`);
          return res.status(400).json({ success: false, error: '–ù–∞ —Ñ–æ—Ç–æ –æ–±–Ω–∞—Ä—É–∂–µ–Ω –º–µ–º, —Ñ–µ–π–∫ –∏–ª–∏ –∫–∞–¥—Ä –∏–∑ —Ñ–∏–ª—å–º–∞. –ó–∞–≥—Ä—É–∑–∏—Ç–µ —Ä–µ–∞–ª—å–Ω–æ–µ —Ñ–æ—Ç–æ.', needPhoto: 1 });
      }
      }
      // 3. –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–ª–∞ —á–µ—Ä–µ–∑ Face++
      if (FACEPP_API_KEY && FACEPP_API_SECRET) {
        try {
          const faceResult = await detectGenderFacePlusPlus(buffer, FACEPP_API_KEY, FACEPP_API_SECRET);
          console.log(`[uploadPhoto] Face++ gender:`, faceResult);
          if (!faceResult.success) {
            console.warn(`[uploadPhoto] Face++: ${faceResult.error}`);
            return res.status(400).json({ success: false, error: faceResult.error, needPhoto: 1 });
          }
          if ((userRow.gender === 'male' && faceResult.gender === 'Female') ||
              (userRow.gender === 'female' && faceResult.gender === 'Male')) {
            console.warn(`[uploadPhoto] Face++: –ü–æ–ª –Ω–∞ —Ñ–æ—Ç–æ –Ω–µ —Å–æ–≤–ø–∞–¥–∞–µ—Ç —Å –ø–æ–ª–æ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è`);
            return res.status(400).json({ success: false, error: '–ù–∞ —Ñ–æ—Ç–æ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–æ –Ω–µ—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ –ø–æ–ª–∞. –ï—Å–ª–∏ –≤—ã –æ—à–∏–±–ª–∏—Å—å ‚Äî —É–¥–∞–ª–∏—Ç–µ –∞–Ω–∫–µ—Ç—É –∏ –≤—ã–±–µ—Ä–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –ø–æ–ª.', needPhoto: 1 });
          }
        } catch (err) {
          console.error(`[uploadPhoto] Face++ error:`, err);
          return res.status(500).json({ success: false, error: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–∏—Å–∞ Face++', needPhoto: 1 });
        }
      } else {
        console.warn('[uploadPhoto] Face++ –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω, –ø–æ–ª –Ω–µ –ø—Ä–æ–≤–µ—Ä—è–µ—Ç—Å—è!');
      }

      // –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –ø–∞–ø–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
      const ext = '.jpg';
      const userDir = path.join(IMG_DIR, userId);
      console.log(`[uploadPhoto] –ü—Ä–æ–≤–µ—Ä—è—é –ø–∞–ø–∫—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: ${userDir}`);
      try {
        if (!fs.existsSync(userDir)) {
          fs.mkdirSync(userDir, { recursive: true });
          console.log(`[uploadPhoto] ‚úÖ –°–æ–∑–¥–∞–Ω–∞ –ø–∞–ø–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: ${userDir}`);
        }
      } catch (mkdirErr) {
        console.error(`[uploadPhoto] ‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ø–∞–ø–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${userDir}: ${mkdirErr.message}`);
        return res.status(500).json({ success: false, error: '–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ø–∞–ø–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è' });
      }

      // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–∏–µ —Å–ª–æ—Ç—ã –∏–∑ –ë–î
      const row = await new Promise((resolve, reject) =>
        db.get('SELECT photo1, photo2, photo3 FROM users WHERE userId = ?', [userId],
               (err, r) => err ? reject(err) : resolve(r))
      );
      let p1 = (row.photo1 || '').trim();
      let p2 = (row.photo2 || '').trim();
      let p3 = (row.photo3 || '').trim();
      console.log(`Current slots before upload: p1="${p1}", p2="${p2}", p3="${p3}"`);

      // Verify actual file existence; clear stale DB entries
      for (const [col, urlRef] of [['photo1', p1], ['photo2', p2], ['photo3', p3]]) {
        if (urlRef) {
          const file = path.basename(urlRef);
          const fp = path.join(userDir, file);
          if (!fs.existsSync(fp)) {
            console.warn(`Stale DB entry for ${col}: file not found ${fp}, clearing slot`);
            db.run(`UPDATE users SET ${col} = "" WHERE userId = ?`, [userId], err => {
              if (err) console.error(`Failed to clear stale ${col}: ${err.message}`);
            });
            if (col === 'photo1') p1 = '';
            if (col === 'photo2') p2 = '';
            if (col === 'photo3') p3 = '';
          }
        }
      }

      let chosenSlot;

      let fileName;
      if (!p1) {
        chosenSlot = 'photo1';
        console.log(`Chosen slot: ${chosenSlot}`);
        fileName = `Photo1${ext}`;
      } else if (!p2) {
        chosenSlot = 'photo2';
        console.log(`Chosen slot: ${chosenSlot}`);
        fileName = `Photo2${ext}`;
      } else if (!p3) {
        chosenSlot = 'photo3';
        console.log(`Chosen slot: ${chosenSlot}`);
        fileName = `Photo3${ext}`;
      } else {
        chosenSlot = 'rotate';
        console.log('Chosen slot: rotate (cyclic shift)');
        const archiveDir = path.join(userDir, 'archive');
        if (!fs.existsSync(archiveDir)) fs.mkdirSync(archiveDir, { recursive: true });
        // 1) –ê—Ä—Ö–∏–≤–∏—Ä—É–µ–º photo1
        if (p1) {
          const f1 = path.basename(p1);
          fs.renameSync(path.join(userDir, f1), path.join(archiveDir, f1));
        }
        // 2) –°–¥–≤–∏–≥–∞–µ–º photo2 ‚Üí Photo1.jpg
        if (p2) {
          const f2 = path.basename(p2);
          fs.renameSync(path.join(userDir, f2), path.join(userDir, `Photo1${ext}`));
        }
        // 3) –°–¥–≤–∏–≥–∞–µ–º photo3 ‚Üí Photo2.jpg
        if (p3) {
          const f3 = path.basename(p3);
          fs.renameSync(path.join(userDir, f3), path.join(userDir, `Photo2${ext}`));
        }
        // –ù–æ–≤—ã–π —Ñ–∞–π–ª –≤ Photo3.jpg
        fileName = `Photo3${ext}`;
      }

      // –°–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–æ–≤–æ–µ —Ñ–æ—Ç–æ
      const destPath = path.join(userDir, fileName);
      console.log(`Writing file to ${destPath}`);
      fs.writeFileSync(destPath, buffer);
      const slotUrl = `/data/img/${userId}/${fileName}`;

      // –ü—Ä–∏ rotate –æ–±–Ω–æ–≤–ª—è–µ–º —Å—Ä–∞–∑—É –≤—Å–µ —Ç—Ä–∏ —Å–ª–æ—Ç–∞, –∏–Ω–∞—á–µ —Ç–æ–ª—å–∫–æ –≤—ã–±—Ä–∞–Ω–Ω—ã–π
      if (chosenSlot === 'rotate') {
        const url1 = p2 ? `/data/img/${userId}/Photo1${ext}` : '';
        const url2 = p3 ? `/data/img/${userId}/Photo2${ext}` : '';
        const url3 = slotUrl;
        await new Promise((resolve, reject) =>
          db.run(
            `UPDATE users SET photo1 = ?, photo2 = ?, photo3 = ?, needPhoto = 0, warned = 0 WHERE userId = ?`,
            [url1, url2, url3, userId],
            err => err ? reject(err) : resolve()
          )
        );
      } else {
        const column = fileName.startsWith('Photo1') ? 'photo1'
                     : fileName.startsWith('Photo2') ? 'photo2'
                     : 'photo3';
        await new Promise((resolve, reject) =>
          db.run(
            `UPDATE users SET ${column} = ?, needPhoto = 0, warned = 0 WHERE userId = ?`,
            [slotUrl, userId],
            err => err ? reject(err) : resolve()
          )
        );
      }
      console.log(`Successfully updated DB for slot ${chosenSlot}, URL: ${slotUrl}`);

      // –û–±–Ω–æ–≤–∏—Ç—å needPhoto - –µ—Å–ª–∏ Google Vision —Ä–∞–±–æ—Ç–∞–µ—Ç –∏ –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–æ—à–ª–∞ —É—Å–ø–µ—à–Ω–æ, —Ç–æ needPhoto = 0
      // –ï—Å–ª–∏ Google Vision –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç, —Ç–æ needPhoto –æ—Å—Ç–∞–µ—Ç—Å—è 1 (–Ω—É–∂–Ω–æ —Ñ–æ—Ç–æ)
      if (visionClient) {
        // Google Vision —Ä–∞–±–æ—Ç–∞–µ—Ç, –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–æ—à–ª–∞ —É—Å–ø–µ—à–Ω–æ, —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º needPhoto = 0
        await new Promise((resolve, reject) => {
          db.run('UPDATE users SET needPhoto = 0 WHERE userId = ?', [userId], function(err) {
            if (err) reject(err); else resolve();
          });
        });
        console.log(`Google Vision —Ä–∞–±–æ—Ç–∞–µ—Ç, needPhoto —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –≤ 0 –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${userId}`);
      } else {
        // Google Vision –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç, –æ—Å—Ç–∞–≤–ª—è–µ–º needPhoto = 1
        console.log(`Google Vision –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç, needPhoto –æ—Å—Ç–∞–µ—Ç—Å—è 1 –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${userId}`);
      }
      // –í–µ—Ä–Ω—É—Ç—å –∞–∫—Ç—É–∞–ª—å–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
      const userRowFull = await new Promise((resolve, reject) =>
        db.get('SELECT * FROM users WHERE userId = ?', [userId], (err, r) => err ? reject(err) : resolve(r))
      );
      res.json({ success: true, url: `/data/img/${userId}/${fileName}`, user: userRowFull });

    } catch (err) {
      if (req.file && fs.existsSync(req.file.path)) fs.unlinkSync(req.file.path);
      console.error(`/api/photos/upload error: ${err.message}\n${err.stack}`);
      return res.status(500).json({ success: false, error: err.message });
    }
  });

  /**
   * JSON-upload
   * POST /api/photos/uploadUrl  –∏  POST /api/photos/webUploadPhoto
   * body: { userId, fileUrl }
   */
  router.post('/webUploadPhoto', upload.single('file'), async (req, res) => {
    try {
      const { userId } = req.body;
      console.log(`[webUploadPhoto] –ù–∞—á–∞–ª–æ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–∞ –¥–ª—è userId=${userId}`);
      const localPath = req.file.path;
      console.log(`[webUploadPhoto] –í—Ä–µ–º–µ–Ω–Ω—ã–π –ø—É—Ç—å —Ñ–∞–π–ª–∞: ${localPath}`);

      // –í–†–ï–ú–ï–ù–ù–û –û–¢–ö–õ–Æ–ß–ê–ï–ú –ü–†–û–í–ï–†–ö–£ –õ–ò–¶–ê –î–õ–Ø –¢–ï–°–¢–ò–†–û–í–ê–ù–ò–Ø
      console.log('[webUploadPhoto] –í–†–ï–ú–ï–ù–ù–û: –ø—Ä–æ–≤–µ—Ä–∫–∞ –ª–∏—Ü–∞ –æ—Ç–∫–ª—é—á–µ–Ω–∞ –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è');
      let hasFace = true;

      try {
        // 2. –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ Telegram –∫–∞–∫ –≤ —ç—Ç–∞–ª–æ–Ω–µ
        const { bot } = require('../bot');
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞ –∏ –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º HEIC –≤ JPEG –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
        const fileBuffer = fs.readFileSync(localPath);
        const firstBytes = fileBuffer.slice(0, 4);
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —ç—Ç–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
        const isJPEG = firstBytes[0] === 0xFF && firstBytes[1] === 0xD8;
        const isPNG = firstBytes[0] === 0x89 && firstBytes[1] === 0x50 && firstBytes[2] === 0x4E && firstBytes[3] === 0x47;
        const isGIF = firstBytes[0] === 0x47 && firstBytes[1] === 0x49 && firstBytes[2] === 0x46;
        
        let telegramBuffer = fileBuffer;
        let telegramFilePath = localPath;
        
        if (!isJPEG && !isPNG && !isGIF) {
          console.log('[webUploadPhoto] –û–±–Ω–∞—Ä—É–∂–µ–Ω HEIC —Ñ–∞–π–ª, –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ JPEG...');
          try {
            telegramBuffer = await convertHeicToJpeg(fileBuffer);
            telegramFilePath = localPath + '.jpg';
            fs.writeFileSync(telegramFilePath, telegramBuffer);
            console.log('[webUploadPhoto] HEIC —É—Å–ø–µ—à–Ω–æ –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞–Ω –≤ JPEG');
          } catch (error) {
            console.error('[webUploadPhoto] –û—à–∏–±–∫–∞ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ HEIC:', error);
            // –ï—Å–ª–∏ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –Ω–µ —É–¥–∞–ª–∞—Å—å, –∏—Å–ø–æ–ª—å–∑—É–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π —Ñ–∞–π–ª
            telegramBuffer = fileBuffer;
            telegramFilePath = localPath;
          }
        }
        
        const tgMsg = await bot.telegram.sendPhoto(
          String(userId),
          { source: fs.createReadStream(telegramFilePath) }
        );
        const messageId = tgMsg.message_id;
        const fileId = tgMsg.photo.pop().file_id;

        // --- –ó–∞–º–µ–Ω—ë–Ω–Ω—ã–π —É—á–∞—Å—Ç–æ–∫ ---
        const tgFile = await bot.telegram.getFile(fileId);
        const telegramPath = tgFile.file_path;
        const downloadUrl = `https://api.telegram.org/file/bot${BOT_TOKEN}/${telegramPath}`;

        // –°–∫–∞—á–∏–≤–∞–µ–º —Ñ–∞–π–ª —Å Telegram
        const resp = await fetch(downloadUrl);
        const buffer = await resp.buffer();

        // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ –∏ —Ü–µ–ª–µ–≤—É—é –ø–∞–ø–∫—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        const ext = path.extname(telegramPath) || '.jpg';
        const userFolder = path.join(IMG_DIR, String(userId));
        if (!fs.existsSync(userFolder)) {
          fs.mkdirSync(userFolder, { recursive: true });
        }

        // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∏–º—è —Ñ–∞–π–ª–∞ –ø–æ –ø–µ—Ä–≤–æ–º—É —Å–≤–æ–±–æ–¥–Ω–æ–º—É —Å–ª–æ—Ç—É —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        const sqlSel = `SELECT photo1, photo2, photo3 FROM users WHERE userId=?`;
        const row = await new Promise((resolve, reject) => {
          db.get(sqlSel, [String(userId)], (err, row) => err ? reject(err) : resolve(row));
        });
        const p1 = (row.photo1 ?? '').trim();
        const p2 = (row.photo2 ?? '').trim();
        let filename;
        if (!p1) filename = 'Photo1' + ext;
        else if (!p2) filename = 'Photo2' + ext;
        else filename = 'Photo3' + ext;

        // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ñ–∞–π–ª –ª–æ–∫–∞–ª—å–Ω–æ
        const localFilePath = path.join(userFolder, filename);
        fs.writeFileSync(localFilePath, buffer);

        // –§–æ—Ä–º–∏—Ä—É–µ–º URL –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ —á–µ—Ä–µ–∑ —Å–µ—Ä–≤–µ—Ä
        const serverDomain = process.env.SERVER_DOMAIN || 'https://sta-alpacco.amvera.io';
        const newPhotoUrl = `${serverDomain}/data/img/${userId}/${filename}`;

        // 3. –°–æ—Ö—Ä–∞–Ω—è–µ–º URL –≤ –ë–î (–ª–æ–∫–∞–ª—å–Ω—ã–π –ø—É—Ç—å)
        await updateUserPhotosInDb(userId, newPhotoUrl);
        // --- –ö–æ–Ω–µ—Ü –∑–∞–º–µ–Ω—ë–Ω–Ω–æ–≥–æ —É—á–∞—Å—Ç–∫–∞ ---

        // Delete the photo message from the Telegram chat
        await bot.telegram.deleteMessage(String(userId), messageId);
        // –£–¥–∞–ª—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã
        fs.unlinkSync(localPath);
        if (telegramFilePath !== localPath && fs.existsSync(telegramFilePath)) {
          fs.unlinkSync(telegramFilePath);
          console.log('[webUploadPhoto] –£–¥–∞–ª–µ–Ω –≤—Ä–µ–º–µ–Ω–Ω—ã–π JPEG —Ñ–∞–π–ª');
        }

        res.json({ success: true, url: newPhotoUrl });
      } catch (err) {
        // –£–¥–∞–ª—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã –¥–∞–∂–µ –ø—Ä–∏ –æ—à–∏–±–∫–µ
        fs.unlinkSync(localPath);
        if (telegramFilePath !== localPath && fs.existsSync(telegramFilePath)) {
          fs.unlinkSync(telegramFilePath);
          console.log('[webUploadPhoto] –£–¥–∞–ª–µ–Ω –≤—Ä–µ–º–µ–Ω–Ω—ã–π JPEG —Ñ–∞–π–ª –ø—Ä–∏ –æ—à–∏–±–∫–µ');
        }
        console.error("‚ùå /api/webUploadPhoto error:", err);
        res.status(500).json({ success: false, error: err.message });
      }
    } catch (err) {
      console.error("/api/webUploadPhoto (multipart) error:", err);
      return res.status(500).json({ success: false, error: err.message });
    }
  });

  router.post('/uploadUrl', async (req, res) => {
      try {
        const { userId } = req.body;
        console.log(`[webUploadPhoto] –ù–∞—á–∞–ª–æ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–∞ –¥–ª—è userId=${userId}`);
        const localPath = req.file.path;
        console.log(`[webUploadPhoto] –í—Ä–µ–º–µ–Ω–Ω—ã–π –ø—É—Ç—å —Ñ–∞–π–ª–∞: ${localPath}`);

        // –í–†–ï–ú–ï–ù–ù–û –û–¢–ö–õ–Æ–ß–ê–ï–ú –ü–†–û–í–ï–†–ö–£ –õ–ò–¶–ê –î–õ–Ø –¢–ï–°–¢–ò–†–û–í–ê–ù–ò–Ø
        console.log('[webUploadPhoto] –í–†–ï–ú–ï–ù–ù–û: –ø—Ä–æ–≤–µ—Ä–∫–∞ –ª–∏—Ü–∞ –æ—Ç–∫–ª—é—á–µ–Ω–∞ –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è');
        let hasFace = true;

        try {
          // 2. –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ Telegram –∫–∞–∫ –≤ —ç—Ç–∞–ª–æ–Ω–µ
          const { bot } = require('../bot');
          
          // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞ –∏ –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º HEIC –≤ JPEG –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
          const fileBuffer = fs.readFileSync(localPath);
          const firstBytes = fileBuffer.slice(0, 4);
          
          // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —ç—Ç–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
          const isJPEG = firstBytes[0] === 0xFF && firstBytes[1] === 0xD8;
          const isPNG = firstBytes[0] === 0x89 && firstBytes[1] === 0x50 && firstBytes[2] === 0x4E && firstBytes[3] === 0x47;
          const isGIF = firstBytes[0] === 0x47 && firstBytes[1] === 0x49 && firstBytes[2] === 0x46;
          
          let telegramBuffer = fileBuffer;
          let telegramFilePath = localPath;
          
          if (!isJPEG && !isPNG && !isGIF) {
            console.log('[webUploadPhoto] –û–±–Ω–∞—Ä—É–∂–µ–Ω HEIC —Ñ–∞–π–ª, –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ JPEG...');
            try {
              telegramBuffer = await convertHeicToJpeg(fileBuffer);
              telegramFilePath = localPath + '.jpg';
              fs.writeFileSync(telegramFilePath, telegramBuffer);
              console.log('[webUploadPhoto] HEIC —É—Å–ø–µ—à–Ω–æ –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞–Ω –≤ JPEG');
            } catch (error) {
              console.error('[webUploadPhoto] –û—à–∏–±–∫–∞ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ HEIC:', error);
              // –ï—Å–ª–∏ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –Ω–µ —É–¥–∞–ª–∞—Å—å, –∏—Å–ø–æ–ª—å–∑—É–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π —Ñ–∞–π–ª
              telegramBuffer = fileBuffer;
              telegramFilePath = localPath;
            }
          }
          
          const tgMsg = await bot.telegram.sendPhoto(
            String(userId),
            { source: fs.createReadStream(telegramFilePath) }
          );
          const messageId = tgMsg.message_id;
          const fileId = tgMsg.photo.pop().file_id;

          // --- –ó–∞–º–µ–Ω—ë–Ω–Ω—ã–π —É—á–∞—Å—Ç–æ–∫ ---
          const tgFile = await bot.telegram.getFile(fileId);
          const telegramPath = tgFile.file_path;
          const downloadUrl = `https://api.telegram.org/file/bot${BOT_TOKEN}/${telegramPath}`;

          // –°–∫–∞—á–∏–≤–∞–µ–º —Ñ–∞–π–ª —Å Telegram
          const resp = await fetch(downloadUrl);
          const buffer = await resp.buffer();

          // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ –∏ —Ü–µ–ª–µ–≤—É—é –ø–∞–ø–∫—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
          const ext = path.extname(telegramPath) || '.jpg';
          const userFolder = path.join(IMG_DIR, String(userId));
          if (!fs.existsSync(userFolder)) {
            fs.mkdirSync(userFolder, { recursive: true });
          }

          // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∏–º—è —Ñ–∞–π–ª–∞ –ø–æ –ø–µ—Ä–≤–æ–º—É —Å–≤–æ–±–æ–¥–Ω–æ–º—É —Å–ª–æ—Ç—É —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
          const sqlSel = `SELECT photo1, photo2, photo3 FROM users WHERE userId=?`;
          const row = await new Promise((resolve, reject) => {
            db.get(sqlSel, [String(userId)], (err, row) => err ? reject(err) : resolve(row));
          });
          const p1 = (row.photo1 ?? '').trim();
          const p2 = (row.photo2 ?? '').trim();
          let filename;
          if (!p1) filename = 'Photo1' + ext;
          else if (!p2) filename = 'Photo2' + ext;
          else filename = 'Photo3' + ext;

          // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ñ–∞–π–ª –ª–æ–∫–∞–ª—å–Ω–æ
          const localFilePath = path.join(userFolder, filename);
          fs.writeFileSync(localFilePath, buffer);

          // –§–æ—Ä–º–∏—Ä—É–µ–º URL –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ —á–µ—Ä–µ–∑ —Å–µ—Ä–≤–µ—Ä
          const serverDomain = process.env.SERVER_DOMAIN || 'https://sta-alpacco.amvera.io';
          const newPhotoUrl = `${serverDomain}/data/img/${userId}/${filename}`;

          // 3. –°–æ—Ö—Ä–∞–Ω—è–µ–º URL –≤ –ë–î (–ª–æ–∫–∞–ª—å–Ω—ã–π –ø—É—Ç—å)
          await updateUserPhotosInDb(userId, newPhotoUrl);
          // --- –ö–æ–Ω–µ—Ü –∑–∞–º–µ–Ω—ë–Ω–Ω–æ–≥–æ —É—á–∞—Å—Ç–∫–∞ ---

          // Delete the photo message from the Telegram chat
          await bot.telegram.deleteMessage(String(userId), messageId);
          // –£–¥–∞–ª—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã
          fs.unlinkSync(localPath);
          if (telegramFilePath !== localPath && fs.existsSync(telegramFilePath)) {
            fs.unlinkSync(telegramFilePath);
            console.log('[webUploadPhoto] –£–¥–∞–ª–µ–Ω –≤—Ä–µ–º–µ–Ω–Ω—ã–π JPEG —Ñ–∞–π–ª');
          }

          res.json({ success: true, url: newPhotoUrl });
        } catch (err) {
          // –£–¥–∞–ª—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã –¥–∞–∂–µ –ø—Ä–∏ –æ—à–∏–±–∫–µ
          fs.unlinkSync(localPath);
          if (telegramFilePath !== localPath && fs.existsSync(telegramFilePath)) {
            fs.unlinkSync(telegramFilePath);
            console.log('[webUploadPhoto] –£–¥–∞–ª–µ–Ω –≤—Ä–µ–º–µ–Ω–Ω—ã–π JPEG —Ñ–∞–π–ª –ø—Ä–∏ –æ—à–∏–±–∫–µ');
          }
          console.error("‚ùå /api/webUploadPhoto error:", err);
          res.status(500).json({ success: false, error: err.message });
        }
      } catch (err) {
        console.error("/api/webUploadPhoto (multipart) error:", err);
        return res.status(500).json({ success: false, error: err.message });
      }
    }
      const { userId, fileUrl } = req.body;
      console.log(`uploadUrl called for user ${userId}, fileUrl: ${fileUrl}`);
      if (!userId || !fileUrl) {
        return res.status(400).json({ success: false, error: 'userId –∏ fileUrl –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã' });
      }
      const resp = await fetch(fileUrl);
      if (!resp.ok) throw new Error(`Fetch failed: ${resp.statusText}`);
      const buffer = await resp.buffer();

      // –ü–æ–ª—É—á–∞–µ–º –ø–æ–ª –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ –ë–î –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏
      const userRow = await new Promise((resolve, reject) =>
        db.get('SELECT gender FROM users WHERE userId = ?', [userId],
               (err, r) => err ? reject(err) : resolve(r))
      );
      
      if (!userRow || !userRow.gender) {
        return res.status(400).json({ success: false, error: '–ü–æ–ª –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –Ω–µ —É–∫–∞–∑–∞–Ω. –°–Ω–∞—á–∞–ª–∞ —É–∫–∞–∂–∏—Ç–µ —Å–≤–æ–π –ø–æ–ª.' });
      }

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –ª–∏—Ü–∞ –Ω–∞ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏ —á–µ—Ä–µ–∑ Google Vision
      if (visionClient) {
        console.log(`–ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –ª–∏—Ü–∞ –Ω–∞ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${userId}`);
        const faceCheck = await checkFaceInPhoto(visionClient, buffer);
        
        if (!faceCheck.success) {
          console.warn(`–ü—Ä–æ–≤–µ—Ä–∫–∞ –ª–∏—Ü–∞ –Ω–µ –ø—Ä–æ–π–¥–µ–Ω–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${userId}: ${faceCheck.error}`);
          return res.status(400).json({ success: false, error: faceCheck.error });
        }
        
        console.log(`–ü—Ä–æ–≤–µ—Ä–∫–∞ –ª–∏—Ü–∞ –ø—Ä–æ–π–¥–µ–Ω–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${userId}: –Ω–∞–π–¥–µ–Ω–æ –ª–∏—Ü (–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ: ${faceCheck.faceCount})`);
      }

      // Face++ gender check
      if (FACEPP_API_KEY && FACEPP_API_SECRET) {
        try {
          const faceResult = await detectGenderFacePlusPlus(buffer, FACEPP_API_KEY, FACEPP_API_SECRET);
          console.log(`[uploadUrl] Face++ gender:`, faceResult);
          if (!faceResult.success) {
            console.warn(`[uploadUrl] Face++: ${faceResult.error}`);
            return res.status(400).json({ success: false, error: faceResult.error });
          }
          if ((userRow.gender === 'male' && faceResult.gender === 'Female') ||
              (userRow.gender === 'female' && faceResult.gender === 'Male')) {
            console.warn(`[uploadUrl] Face++: –ü–æ–ª –Ω–∞ —Ñ–æ—Ç–æ –Ω–µ —Å–æ–≤–ø–∞–¥–∞–µ—Ç —Å –ø–æ–ª–æ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è`);
            return res.status(400).json({ success: false, error: '–ù–∞ —Ñ–æ—Ç–æ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–æ –Ω–µ—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ –ø–æ–ª–∞. –ï—Å–ª–∏ –≤—ã –æ—à–∏–±–ª–∏—Å—å ‚Äî —É–¥–∞–ª–∏—Ç–µ –∞–Ω–∫–µ—Ç—É –∏ –≤—ã–±–µ—Ä–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –ø–æ–ª.' });
          }
        } catch (err) {
          console.error(`[uploadUrl] Face++ error:`, err);
          return res.status(500).json({ success: false, error: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–∏—Å–∞ Face++' });
        }
      }

      // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –º–µ–º—ã/—Ñ–µ–π–∫–∏
      if (visionClient) {
        const memeCheck = await isMemeOrFake(visionClient, buffer);
        console.log(`[uploadUrl] Meme check:`, memeCheck);
        if (memeCheck.isMeme) {
          console.warn(`[uploadUrl] –û—Ç–∫–ª–æ–Ω–µ–Ω–æ: –º–µ–º/—Ñ–µ–π–∫ (${memeCheck.reason})`);
          return res.status(400).json({ success: false, error: '–ù–∞ —Ñ–æ—Ç–æ –æ–±–Ω–∞—Ä—É–∂–µ–Ω –º–µ–º, —Ñ–µ–π–∫ –∏–ª–∏ –∫–∞–¥—Ä –∏–∑ —Ñ–∏–ª—å–º–∞. –ó–∞–≥—Ä—É–∑–∏—Ç–µ —Ä–µ–∞–ª—å–Ω–æ–µ —Ñ–æ—Ç–æ.' });
        }
      }

      // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ –∏ –ø—É—Ç–∏
      const ext = '.jpg';
      const targetFolder = path.join(IMG_DIR, userId);
      const archiveFolder = path.join(targetFolder, 'archive');

      // –ü—Ä–æ—á–∏—Ç–∞—Ç—å —Ç–µ–∫—É—â–∏–µ —Å–ª–æ—Ç—ã
      const row = await new Promise((resolve, reject) =>
        db.get('SELECT photo1, photo2, photo3 FROM users WHERE userId = ?', [userId], (e, r) => e ? reject(e) : resolve(r))
      );
      console.log(`Debug slots (JSON) for user ${userId}: photo1="${row.photo1}", photo2="${row.photo2}", photo3="${row.photo3}"`);
      let p1 = (row.photo1 || '').trim();
      let p2 = (row.photo2 || '').trim();
      let p3 = (row.photo3 || '').trim();
      console.log(`Debug slots for user ${userId}: p1="${p1}", p2="${p2}", p3="${p3}"`);
      console.log(`JSON handler current slots: p1="${p1}", p2="${p2}", p3="${p3}"`);

      // Verify actual file existence; clear stale DB entries
      for (const [col, urlRef] of [['photo1', p1], ['photo2', p2], ['photo3', p3]]) {
        if (urlRef) {
          const file = path.basename(urlRef);
          const fp = path.join(targetFolder, file);
          if (!fs.existsSync(fp)) {
            console.warn(`Stale DB entry for ${col}: file not found ${fp}, clearing slot`);
            db.run(`UPDATE users SET ${col} = "" WHERE userId = ?`, [userId], err => {
              if (err) console.error(`Failed to clear stale ${col}: ${err.message}`);
            });
            if (col === 'photo1') p1 = '';
            if (col === 'photo2') p2 = '';
            if (col === 'photo3') p3 = '';
          }
        }
      }

      let chosenSlot;
      // –°–æ–∑–¥–∞—Ç—å –ø–∞–ø–∫—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
      console.log(`[uploadUrl] –ü—Ä–æ–≤–µ—Ä—è—é –ø–∞–ø–∫—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: ${targetFolder}`);
      try {
        if (!fs.existsSync(targetFolder)) {
          fs.mkdirSync(targetFolder, { recursive: true });
          console.log(`[uploadUrl] ‚úÖ –°–æ–∑–¥–∞–Ω–∞ –ø–∞–ø–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: ${targetFolder}`);
        }
      } catch (mkdirErr) {
        console.error(`[uploadUrl] ‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ø–∞–ø–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${targetFolder}: ${mkdirErr.message}`);
        return res.status(500).json({ success: false, error: '–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ø–∞–ø–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è' });
      }
      // –°–ª–æ—Ç 1
      if (!p1) {
        chosenSlot = 'photo1';
        console.log(`Chosen slot: ${chosenSlot}`);
        const fileName = `Photo1${ext}`;
        const destPath = path.join(targetFolder, fileName);
        console.log(`Writing file to ${destPath}`);
        fs.writeFileSync(destPath, buffer);
        const url = `/data/img/${userId}/${fileName}`;
        await new Promise((resolve, reject) =>
          db.run('UPDATE users SET photo1=? WHERE userId=?', [url, userId], err => err ? reject(err) : resolve())
        );
        
        // –û–±–Ω–æ–≤–∏—Ç—å needPhoto - –µ—Å–ª–∏ Google Vision —Ä–∞–±–æ—Ç–∞–µ—Ç –∏ –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–æ—à–ª–∞ —É—Å–ø–µ—à–Ω–æ, —Ç–æ needPhoto = 0
        // –ï—Å–ª–∏ Google Vision –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç, —Ç–æ needPhoto –æ—Å—Ç–∞–µ—Ç—Å—è 1 (–Ω—É–∂–Ω–æ —Ñ–æ—Ç–æ)
        if (visionClient) {
          // Google Vision —Ä–∞–±–æ—Ç–∞–µ—Ç, –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–æ—à–ª–∞ —É—Å–ø–µ—à–Ω–æ, —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º needPhoto = 0
          await new Promise((resolve, reject) => {
            db.run('UPDATE users SET needPhoto = 0, warned = 0 WHERE userId = ?', [userId], function(err) {
              if (err) reject(err); else resolve();
            });
          });
          console.log(`Google Vision —Ä–∞–±–æ—Ç–∞–µ—Ç, needPhoto —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –≤ 0 –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${userId}`);
        } else {
          // Google Vision –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç, –æ—Å—Ç–∞–≤–ª—è–µ–º needPhoto = 1
          console.log(`Google Vision –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç, needPhoto –æ—Å—Ç–∞–µ—Ç—Å—è 1 –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${userId}`);
        }
        console.log(`Successfully updated DB for slot ${chosenSlot}, URL: ${url}`);
        return res.json({ success: true, url });
      }
      // –°–ª–æ—Ç 2
      else if (!p2) {
        chosenSlot = 'photo2';
        console.log(`Chosen slot: ${chosenSlot}`);
        const fileName = `Photo2${ext}`;
        const destPath = path.join(targetFolder, fileName);
        console.log(`Writing file to ${destPath}`);
        fs.writeFileSync(destPath, buffer);
        const url = `/data/img/${userId}/${fileName}`;
        await new Promise((resolve, reject) =>
          db.run('UPDATE users SET photo2=? WHERE userId=?', [url, userId], err => err ? reject(err) : resolve())
        );
        
        // –û–±–Ω–æ–≤–∏—Ç—å needPhoto - –µ—Å–ª–∏ Google Vision —Ä–∞–±–æ—Ç–∞–µ—Ç –∏ –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–æ—à–ª–∞ —É—Å–ø–µ—à–Ω–æ, —Ç–æ needPhoto = 0
        // –ï—Å–ª–∏ Google Vision –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç, —Ç–æ needPhoto –æ—Å—Ç–∞–µ—Ç—Å—è 1 (–Ω—É–∂–Ω–æ —Ñ–æ—Ç–æ)
        if (visionClient) {
          // Google Vision —Ä–∞–±–æ—Ç–∞–µ—Ç, –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–æ—à–ª–∞ —É—Å–ø–µ—à–Ω–æ, —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º needPhoto = 0
          await new Promise((resolve, reject) => {
            db.run('UPDATE users SET needPhoto = 0, warned = 0 WHERE userId = ?', [userId], function(err) {
              if (err) reject(err); else resolve();
            });
          });
          console.log(`Google Vision —Ä–∞–±–æ—Ç–∞–µ—Ç, needPhoto —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –≤ 0 –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${userId}`);
        } else {
          // Google Vision –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç, –æ—Å—Ç–∞–≤–ª—è–µ–º needPhoto = 1
          console.log(`Google Vision –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç, needPhoto –æ—Å—Ç–∞–µ—Ç—Å—è 1 –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${userId}`);
        }
        console.log(`Successfully updated DB for slot ${chosenSlot}, URL: ${url}`);
        return res.json({ success: true, url });
      }
      // –°–ª–æ—Ç 3
      else if (!p3) {
        chosenSlot = 'photo3';
        console.log(`Chosen slot: ${chosenSlot}`);
        const fileName = `Photo3${ext}`;
        const destPath = path.join(targetFolder, fileName);
        console.log(`Writing file to ${destPath}`);
        fs.writeFileSync(destPath, buffer);
        const url = `/data/img/${userId}/${fileName}`;
        await new Promise((resolve, reject) =>
          db.run('UPDATE users SET photo3=? WHERE userId=?', [url, userId], err => err ? reject(err) : resolve())
        );
        
        // –û–±–Ω–æ–≤–∏—Ç—å needPhoto - –µ—Å–ª–∏ Google Vision —Ä–∞–±–æ—Ç–∞–µ—Ç –∏ –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–æ—à–ª–∞ —É—Å–ø–µ—à–Ω–æ, —Ç–æ needPhoto = 0
        // –ï—Å–ª–∏ Google Vision –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç, —Ç–æ needPhoto –æ—Å—Ç–∞–µ—Ç—Å—è 1 (–Ω—É–∂–Ω–æ —Ñ–æ—Ç–æ)
        if (visionClient) {
          // Google Vision —Ä–∞–±–æ—Ç–∞–µ—Ç, –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–æ—à–ª–∞ —É—Å–ø–µ—à–Ω–æ, —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º needPhoto = 0
          await new Promise((resolve, reject) => {
            db.run('UPDATE users SET needPhoto = 0, warned = 0 WHERE userId = ?', [userId], function(err) {
              if (err) reject(err); else resolve();
            });
          });
          console.log(`Google Vision —Ä–∞–±–æ—Ç–∞–µ—Ç, needPhoto —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –≤ 0 –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${userId}`);
        } else {
          // Google Vision –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç, –æ—Å—Ç–∞–≤–ª—è–µ–º needPhoto = 1
          console.log(`Google Vision –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç, needPhoto –æ—Å—Ç–∞–µ—Ç—Å—è 1 –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${userId}`);
        }
        console.log(`Successfully updated DB for slot ${chosenSlot}, URL: ${url}`);
        return res.json({ success: true, url });
      }
      else {
        chosenSlot = 'rotate';
        console.log(`Chosen slot: rotate (cyclic shift)`);
        // Ensure archive folder exists
        if (!fs.existsSync(archiveFolder)) fs.mkdirSync(archiveFolder, { recursive: true });
        // Archive photo1
        if (p1) {
          const file1 = path.basename(p1);
          fs.renameSync(path.join(targetFolder, file1), path.join(archiveFolder, file1));
        }
        // Shift photo2 -> Photo1
        if (p2) {
          const file2 = path.basename(p2);
          fs.renameSync(path.join(targetFolder, file2), path.join(targetFolder, `Photo1${ext}`));
        }
        // Shift photo3 -> Photo2
        if (p3) {
          const file3 = path.basename(p3);
          fs.renameSync(path.join(targetFolder, file3), path.join(targetFolder, `Photo2${ext}`));
        }
        // Save new upload as Photo3
        const newName = `Photo3${ext}`;
        const destPath = path.join(targetFolder, newName);
        console.log(`Writing file to ${destPath}`);
        fs.writeFileSync(destPath, buffer);
        // Build URLs
        const url1 = p2 ? `/data/img/${userId}/Photo1${ext}` : '';
        const url2 = p3 ? `/data/img/${userId}/Photo2${ext}` : '';
        const url3 = `/data/img/${userId}/${newName}`;
        // Update all three columns at once
        await new Promise((resolve, reject) =>
          db.run(
            `UPDATE users SET photo1 = ?, photo2 = ?, photo3 = ? WHERE userId = ?`,
            [url1, url2, url3, userId],
            err => err ? reject(err) : resolve()
          )
        );
        
        // –û–±–Ω–æ–≤–∏—Ç—å needPhoto - –µ—Å–ª–∏ Google Vision —Ä–∞–±–æ—Ç–∞–µ—Ç –∏ –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–æ—à–ª–∞ —É—Å–ø–µ—à–Ω–æ, —Ç–æ needPhoto = 0
        // –ï—Å–ª–∏ Google Vision –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç, —Ç–æ needPhoto –æ—Å—Ç–∞–µ—Ç—Å—è 1 (–Ω—É–∂–Ω–æ —Ñ–æ—Ç–æ)
        if (visionClient) {
          // Google Vision —Ä–∞–±–æ—Ç–∞–µ—Ç, –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–æ—à–ª–∞ —É—Å–ø–µ—à–Ω–æ, —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º needPhoto = 0
          await new Promise((resolve, reject) => {
            db.run('UPDATE users SET needPhoto = 0, warned = 0 WHERE userId = ?', [userId], function(err) {
              if (err) reject(err); else resolve();
            });
          });
          console.log(`Google Vision —Ä–∞–±–æ—Ç–∞–µ—Ç, needPhoto —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –≤ 0 –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${userId}`);
        } else {
          // Google Vision –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç, –æ—Å—Ç–∞–≤–ª—è–µ–º needPhoto = 1
          console.log(`Google Vision –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç, needPhoto –æ—Å—Ç–∞–µ—Ç—Å—è 1 –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${userId}`);
        }
        console.log(`Successfully rotated and updated DB: photo1=${url1}, photo2=${url2}, photo3=${url3}`);
        return res.json({ success: true, url: url3 });
      }
    } catch (err) {
      console.error(`/api/photos/uploadUrl error: ${err.message}`);
      return res.status(500).json({ success: false, error: err.message });
    }
  });

  /**
   * Base64 upload
   * POST /api/photos/uploadBase64
   * body: { userId, photos: [base64string] }
   */
  router.post('/uploadBase64', async (req, res) => {
    try {
      const { userId, photos } = req.body;
      console.log(`uploadBase64 called for user ${userId}, photos count: ${photos?.length || 0}`);
      
      if (!userId || !photos || !Array.isArray(photos) || photos.length === 0) {
        return res.status(400).json({ success: false, error: 'userId –∏ –º–∞—Å—Å–∏–≤ photos –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã' });
      }

      // –ü–æ–ª—É—á–∞–µ–º –ø–æ–ª –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ –ë–î –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏
      const userRow = await new Promise((resolve, reject) =>
        db.get('SELECT gender FROM users WHERE userId = ?', [userId],
               (err, r) => err ? reject(err) : resolve(r))
      );
      
      if (!userRow || !userRow.gender) {
        return res.status(400).json({ success: false, error: '–ü–æ–ª –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –Ω–µ —É–∫–∞–∑–∞–Ω. –°–Ω–∞—á–∞–ª–∞ —É–∫–∞–∂–∏—Ç–µ —Å–≤–æ–π –ø–æ–ª.' });
      }

      const targetFolder = path.join(IMG_DIR, userId);
      console.log(`[uploadBase64] –ü—Ä–æ–≤–µ—Ä—è—é –ø–∞–ø–∫—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: ${targetFolder}`);
      try {
        if (!fs.existsSync(targetFolder)) {
          fs.mkdirSync(targetFolder, { recursive: true });
          console.log(`[uploadBase64] ‚úÖ –°–æ–∑–¥–∞–Ω–∞ –ø–∞–ø–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: ${targetFolder}`);
        }
      } catch (mkdirErr) {
        console.error(`[uploadBase64] ‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ø–∞–ø–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${targetFolder}: ${mkdirErr.message}`);
        return res.status(500).json({ success: false, error: '–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ø–∞–ø–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è' });
      }

      // –ü—Ä–æ—á–∏—Ç–∞—Ç—å —Ç–µ–∫—É—â–∏–µ —Å–ª–æ—Ç—ã
      const row = await new Promise((resolve, reject) =>
        db.get('SELECT photo1, photo2, photo3 FROM users WHERE userId = ?', [userId], (e, r) => e ? reject(e) : resolve(r))
      );
      
      let p1 = (row.photo1 || '').trim();
      let p2 = (row.photo2 || '').trim();
      let p3 = (row.photo3 || '').trim();

      const uploadedUrls = [];
      let needPhotoUpdated = false;

      for (let i = 0; i < Math.min(photos.length, 3); i++) {
        const base64Data = photos[i];
        if (!base64Data || !base64Data.startsWith('data:image/')) {
          console.warn(`–ü—Ä–æ–ø—É—Å–∫–∞–µ–º –Ω–µ–≤–∞–ª–∏–¥–Ω–æ–µ —Ñ–æ—Ç–æ ${i + 1} –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${userId}`);
          continue;
        }

        // –ò–∑–≤–ª–µ–∫–∞–µ–º base64 –¥–∞–Ω–Ω—ã–µ
        const base64Match = base64Data.match(/^data:image\/([a-zA-Z]+);base64,(.+)$/);
        if (!base64Match) {
          console.warn(`–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç base64 –¥–ª—è —Ñ–æ—Ç–æ ${i + 1} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${userId}`);
          continue;
        }

        const [, imageType, base64String] = base64Match;
        const buffer = Buffer.from(base64String, 'base64');

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –ª–∏—Ü–∞ –Ω–∞ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏ —á–µ—Ä–µ–∑ Google Vision
        if (visionClient) {
          console.log(`–ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –ª–∏—Ü–∞ –Ω–∞ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏ ${i + 1} –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${userId}`);
          const faceCheck = await checkFaceInPhoto(visionClient, buffer);
          
          if (!faceCheck.success) {
            console.warn(`–ü—Ä–æ–≤–µ—Ä–∫–∞ –ª–∏—Ü–∞ –Ω–µ –ø—Ä–æ–π–¥–µ–Ω–∞ –¥–ª—è —Ñ–æ—Ç–æ ${i + 1} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${userId}: ${faceCheck.error}`);
            continue; // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —ç—Ç–æ —Ñ–æ—Ç–æ, –Ω–æ –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º —Å –¥—Ä—É–≥–∏–º–∏
          }
          
          console.log(`–ü—Ä–æ–≤–µ—Ä–∫–∞ –ª–∏—Ü–∞ –ø—Ä–æ–π–¥–µ–Ω–∞ –¥–ª—è —Ñ–æ—Ç–æ ${i + 1} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${userId}: –Ω–∞–π–¥–µ–Ω–æ –ª–∏—Ü (–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ: ${faceCheck.faceCount})`);
        }

        // Face++ gender check
        if (FACEPP_API_KEY && FACEPP_API_SECRET) {
          try {
            const faceResult = await detectGenderFacePlusPlus(buffer, FACEPP_API_KEY, FACEPP_API_SECRET);
            console.log(`[uploadBase64] Face++ gender:`, faceResult);
            if (!faceResult.success) {
              console.warn(`[uploadBase64] Face++: ${faceResult.error}`);
              continue;
            }
            if ((userRow.gender === 'male' && faceResult.gender === 'Female') ||
                (userRow.gender === 'female' && faceResult.gender === 'Male')) {
              console.warn(`[uploadBase64] Face++: –ü–æ–ª –Ω–∞ —Ñ–æ—Ç–æ –Ω–µ —Å–æ–≤–ø–∞–¥–∞–µ—Ç —Å –ø–æ–ª–æ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è`);
              continue;
            }
          } catch (err) {
            console.error(`[uploadBase64] Face++ error:`, err);
            continue;
          }
        }

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –º–µ–º—ã/—Ñ–µ–π–∫–∏
        if (visionClient) {
          const memeCheck = await isMemeOrFake(visionClient, buffer);
          console.log(`[uploadBase64] Meme check:`, memeCheck);
          if (memeCheck.isMeme) {
            console.warn(`[uploadBase64] –û—Ç–∫–ª–æ–Ω–µ–Ω–æ: –º–µ–º/—Ñ–µ–π–∫ (${memeCheck.reason})`);
            continue;
          }
        }

        // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å–ª–æ—Ç –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è
        let slotColumn = null;
        let fileName = null;
        
        if (!p1) {
          slotColumn = 'photo1';
          fileName = 'Photo1.jpg';
          p1 = 'filled';
        } else if (!p2) {
          slotColumn = 'photo2';
          fileName = 'Photo2.jpg';
          p2 = 'filled';
        } else if (!p3) {
          slotColumn = 'photo3';
          fileName = 'Photo3.jpg';
          p3 = 'filled';
        } else {
          // –í—Å–µ —Å–ª–æ—Ç—ã –∑–∞–Ω—è—Ç—ã, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º
          console.log(`–í—Å–µ —Å–ª–æ—Ç—ã –∑–∞–Ω—è—Ç—ã –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${userId}, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º —Ñ–æ—Ç–æ ${i + 1}`);
          continue;
        }

        // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ñ–∞–π–ª
        const destPath = path.join(targetFolder, fileName);
        console.log(`–°–æ—Ö—Ä–∞–Ω—è–µ–º —Ñ–æ—Ç–æ ${i + 1} –≤ ${destPath}`);
        fs.writeFileSync(destPath, buffer);
        
        const url = `/data/img/${userId}/${fileName}`;
        uploadedUrls.push(url);

        // –û–±–Ω–æ–≤–ª—è–µ–º –ë–î
        await new Promise((resolve, reject) =>
          db.run(`UPDATE users SET ${slotColumn} = ? WHERE userId = ?`, [url, userId], err => err ? reject(err) : resolve())
        );
        
        needPhotoUpdated = true;
        console.log(`–§–æ—Ç–æ ${i + 1} —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ: ${url}`);
      }

      // –û–±–Ω–æ–≤–ª—è–µ–º needPhoto –µ—Å–ª–∏ —Ö–æ—Ç—è –±—ã –æ–¥–Ω–æ —Ñ–æ—Ç–æ –±—ã–ª–æ –∑–∞–≥—Ä—É–∂–µ–Ω–æ
      if (needPhotoUpdated) {
        // –û–±–Ω–æ–≤–∏—Ç—å needPhoto - –µ—Å–ª–∏ Google Vision —Ä–∞–±–æ—Ç–∞–µ—Ç –∏ –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–æ—à–ª–∞ —É—Å–ø–µ—à–Ω–æ, —Ç–æ needPhoto = 0
        // –ï—Å–ª–∏ Google Vision –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç, —Ç–æ needPhoto –æ—Å—Ç–∞–µ—Ç—Å—è 1 (–Ω—É–∂–Ω–æ —Ñ–æ—Ç–æ)
        if (visionClient) {
          // Google Vision —Ä–∞–±–æ—Ç–∞–µ—Ç, –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–æ—à–ª–∞ —É—Å–ø–µ—à–Ω–æ, —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º needPhoto = 0
          await new Promise((resolve, reject) => {
            db.run('UPDATE users SET needPhoto = 0, warned = 0 WHERE userId = ?', [userId], function(err) {
              if (err) reject(err); else resolve();
            });
          });
          console.log(`Google Vision —Ä–∞–±–æ—Ç–∞–µ—Ç, needPhoto —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –≤ 0 –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${userId}`);
        } else {
          // Google Vision –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç, –æ—Å—Ç–∞–≤–ª—è–µ–º needPhoto = 1
          console.log(`Google Vision –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç, needPhoto –æ—Å—Ç–∞–µ—Ç—Å—è 1 –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${userId}`);
        }
      }

      // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∞–∫—Ç—É–∞–ª—å–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
      const userRowFull = await new Promise((resolve, reject) =>
        db.get('SELECT * FROM users WHERE userId = ?', [userId], (err, r) => err ? reject(err) : resolve(r))
      );

      res.json({ 
        success: true, 
        uploadedUrls,
        user: userRowFull 
      });

    } catch (err) {
      console.error(`/api/photos/uploadBase64 error: ${err.message}`);
      return res.status(500).json({ success: false, error: err.message });
    }
  });

  /**
   * –£–¥–∞–ª–∏—Ç—å —Ñ–æ—Ç–æ
   * POST /api/photos/deletePhoto
   * body: { userId, photoUrl }
   */
  router.post('/deletePhoto', express.json(), async (req, res) => {
    const { userId, photoUrl } = req.body;
    console.log(`[POST /api/deletePhoto] for user ${userId}, photo: ${photoUrl}`);

    if (!userId || !photoUrl) {
      return res.status(400).json({ success: false, error: 'userId and photoUrl are required' });
    }

    try {
      const row = await new Promise((resolve, reject) => {
        db.get('SELECT photo1, photo2, photo3 FROM users WHERE userId = ?', [userId], (err, r) => err ? reject(err) : resolve(r));
      });

      if (!row) {
        return res.status(404).json({ success: false, error: 'User not found' });
      }

      let columnToUpdate = null;
      if (row.photo1 === photoUrl) columnToUpdate = 'photo1';
      else if (row.photo2 === photoUrl) columnToUpdate = 'photo2';
      else if (row.photo3 === photoUrl) columnToUpdate = 'photo3';

      if (!columnToUpdate) {
        console.warn(`[POST /api/deletePhoto] Photo URL ${photoUrl} not found for user ${userId}`);
        return res.json({ success: true, message: 'Photo not found or already deleted' });
      }

      // Delete file from filesystem
      const userDir = path.join(IMG_DIR, userId);
      const photoPath = path.join(userDir, path.basename(photoUrl));
      if (fs.existsSync(photoPath)) {
        fs.unlinkSync(photoPath);
        console.log(`[POST /api/deletePhoto] Deleted file ${photoPath}`);
      } else {
        console.warn(`[POST /api/deletePhoto] File not found at path ${photoPath}, but proceeding to update DB.`);
      }

      // Update DB
      await new Promise((resolve, reject) => {
        db.run(`UPDATE users SET ${columnToUpdate} = "" WHERE userId = ?`, [userId], function(err) {
          if (err) reject(err);
          else resolve();
        });
      });
      
      console.log(`[POST /api/deletePhoto] Photo slot ${columnToUpdate} cleared for user ${userId}`);
      res.json({ success: true, message: 'Photo deleted successfully' });

    } catch (err) {
      console.error(`/api/photos/deletePhoto error: ${err.message}`);
      res.status(500).json({ success: false, error: err.message });
    }
  });

  /**
   * –û—á–∏—Å—Ç–∏—Ç—å –≤—Å–µ —Ñ–æ—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–Ω–µ–∑–∞–¥–æ–∫—É–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–æ)
   * POST /api/photos/clear
   * body: { userId }
   */
  router.post('/clear', express.json(), (req, res) => {
    const { userId } = req.body;
    if (!userId) return res.status(400).json({ success: false, error: 'userId –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω' });
    
    console.log(`[POST /api/clear] Clearing all photos for user ${userId}`);
    
    const userDir = path.join(IMG_DIR, userId);
    if (fs.existsSync(userDir)) {
      fs.rmSync(userDir, { recursive: true, force: true });
      console.log(`[POST /api/clear] Deleted directory ${userDir}`);
    }
    
    db.run('UPDATE users SET photo1 = "", photo2 = "", photo3 = "" WHERE userId = ?', [userId], err => {
      if (err) {
        console.error(`/api/photos/clear error: ${err.message}`);
        return res.status(500).json({ success: false, error: err.message });
      }
      console.log(`[POST /api/clear] Cleared all photo slots in DB for user ${userId}`);
      res.json({ success: true, message: 'All photos cleared' });
    });
  });

  /**
   * –ü—Ä–æ–≤–µ—Ä–∫–∞ photoUrl (–Ω–∞–ø—Ä–∏–º–µ—Ä, Telegram-–∞–≤–∞—Ç–∞—Ä–∞) —á–µ—Ä–µ–∑ Vision
   * POST /api/photos/checkPhotoUrl
   * body: { userId, photoUrl, gender }
   */
  router.post('/checkPhotoUrl', async (req, res) => {
    const { userId, photoUrl, gender } = req.body;
    console.log(`[POST /api/photos/checkPhotoUrl] userId=${userId}, photoUrl=${photoUrl}, gender=${gender}`);
    if (!userId || !photoUrl || !gender) {
      console.warn('[POST /api/photos/checkPhotoUrl] –ù–µ —Ö–≤–∞—Ç–∞–µ—Ç –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤');
      return res.status(400).json({ success: false, error: 'userId, photoUrl, gender –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã' });
    }
    if (!visionClient) {
      console.error('[POST /api/photos/checkPhotoUrl] Vision API –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω');
      return res.status(500).json({ success: false, error: 'Vision API –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω' });
    }
    try {
      console.log(`[POST /api/photos/checkPhotoUrl] –ù–∞—á–∏–Ω–∞—é fetch photoUrl: ${photoUrl}`);
      const resp = await fetch(photoUrl);
      console.log(`[POST /api/photos/checkPhotoUrl] fetch –∑–∞–≤–µ—Ä—à—ë–Ω, status: ${resp.status}`);
      if (!resp.ok) throw new Error(`–ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–∞—á–∞—Ç—å —Ñ–æ—Ç–æ: ${resp.statusText}`);
      const buffer = await resp.buffer();
      console.log(`[POST /api/photos/checkPhotoUrl] –§–æ—Ç–æ —Å–∫–∞—á–∞–Ω–æ, —Ä–∞–∑–º–µ—Ä: ${buffer.length} –±–∞–π—Ç`);
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ª–∏—Ü–æ —á–µ—Ä–µ–∑ Vision
      console.log(`[POST /api/photos/checkPhotoUrl] –û—Ç–ø—Ä–∞–≤–ª—è—é —Ñ–æ—Ç–æ –≤ Vision –¥–ª—è userId=${userId}`);
      const faceCheck = await checkFaceInPhoto(visionClient, buffer);
      console.log(`[POST /api/photos/checkPhotoUrl] –û—Ç–≤–µ—Ç Vision:`, faceCheck);
      if (!faceCheck.success) {
        console.warn(`[POST /api/photos/checkPhotoUrl] Vision –Ω–µ –ø—Ä–æ—à—ë–ª: ${faceCheck.error}`);
        // needPhoto=1
        await new Promise((resolve, reject) =>
          db.run('UPDATE users SET needPhoto = 1 WHERE userId = ?', [userId], err => err ? reject(err) : resolve())
        );
        console.log(`[POST /api/photos/checkPhotoUrl] needPhoto=1 —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –¥–ª—è userId=${userId}`);
        return res.json({ success: false, error: faceCheck.error, needPhoto: 1 });
      }
      // –í—Å—ë –æ–∫, needPhoto=0
      await new Promise((resolve, reject) =>
        db.run('UPDATE users SET needPhoto = 0 WHERE userId = ?', [userId], err => err ? reject(err) : resolve())
      );
      console.log(`[POST /api/photos/checkPhotoUrl] –õ–∏—Ü–æ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–æ, needPhoto=0 –¥–ª—è userId=${userId}`);
      return res.json({ success: true, needPhoto: 0 });
    } catch (err) {
      console.error(`[POST /api/photos/checkPhotoUrl] –û—à–∏–±–∫–∞: ${err.message}`);
      await new Promise((resolve, reject) =>
        db.run('UPDATE users SET needPhoto = 1 WHERE userId = ?', [userId], err2 => err2 ? reject(err2) : resolve())
      );
      console.log(`[POST /api/photos/checkPhotoUrl] needPhoto=1 —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω (–æ—à–∏–±–∫–∞) –¥–ª—è userId=${userId}`);
      return res.status(500).json({ success: false, error: err.message, needPhoto: 1 });
    }
  });

  return router;
}

// ===== –•–µ–ª–ø–µ—Ä –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ñ–æ—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–ª–æ–≥–∏–∫–∞ –∫–∞–∫ –≤ —ç—Ç–∞–ª–æ–Ω–µ) =====
async function updateUserPhotosInDb(userId, newPhotoUrl) {
  return new Promise((resolve, reject) => {
    const sqlSel = `SELECT photo1, photo2, photo3 FROM users WHERE userId=?`;
    db.get(sqlSel, [String(userId)], (err, row) => {
      if (err) return reject(err);
      if (!row) return reject(new Error("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω"));
      const p1 = (row.photo1 ?? "").trim();
      const p2 = (row.photo2 ?? "").trim();
      const p3 = (row.photo3 ?? "").trim();
      if (p1 === "") {
        // slot1
        const sqlUpd = `UPDATE users SET photo1=? WHERE userId=?`;
        db.run(sqlUpd, [newPhotoUrl, userId], function(err2) {
          if (err2) return reject(err2);
          db.run(`UPDATE users SET needPhoto=0, warned=0 WHERE userId=?`, [userId]);
          return resolve();
        });
      }
      else if (p2 === "") {
        // slot2
        const sqlUpd = `UPDATE users SET photo2=? WHERE userId=?`;
        db.run(sqlUpd, [newPhotoUrl, userId], function(err2) {
          if (err2) return reject(err2);
          db.run(`UPDATE users SET needPhoto=0, warned=0 WHERE userId=?`, [userId]);
          return resolve();
        });
      }
      else if (p3 === "") {
        // slot3
        const sqlUpd = `UPDATE users SET photo3=? WHERE userId=?`;
        db.run(sqlUpd, [newPhotoUrl, userId], function(err2) {
          if (err2) return reject(err2);
          db.run(`UPDATE users SET needPhoto=0, warned=0 WHERE userId=?`, [userId]);
          return resolve();
        });
      }
      else {
        // –ê—Ä—Ö–∏–≤–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ —Å–¥–≤–∏–≥ (–∫–∞–∫ –≤ /api/uploadPhoto)
        // –î–ª—è webUploadPhoto: –∞—Ä—Ö–∏–≤ –Ω–µ —Ä–µ–∞–ª–∏–∑—É–µ–º, –ø—Ä–æ—Å—Ç–æ —Å–¥–≤–∏–≥–∞–µ–º (–∞—Ä—Ö–∏–≤ –¥–µ–ª–∞–µ—Ç—Å—è –ø—Ä–∏ –ª–æ–∫–∞–ª—å–Ω—ã—Ö —Ñ–∞–π–ª–∞—Ö)
        // –°–¥–≤–∏–≥–∞–µ–º: photo2 -> photo1, photo3 -> photo2, –Ω–æ–≤–æ–µ -> photo3
        const sqlShift = `
          UPDATE users
          SET photo1 = photo2,
              photo2 = photo3,
              photo3 = ?
          WHERE userId = ?
        `;
        db.run(sqlShift, [newPhotoUrl, String(userId)], function(err2) {
          if (err2) return reject(err2);
          db.run(`UPDATE users SET needPhoto=0, warned=0 WHERE userId=?`, [userId]);
          return resolve();
        });
      }
    });
  });
}

// –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º —Ñ—É–Ω–∫—Ü–∏–∏ –≤ –≥–ª–æ–±–∞–ª—å–Ω—É—é –æ–±–ª–∞—Å—Ç—å –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –¥—Ä—É–≥–∏—Ö –º–æ–¥—É–ª—è—Ö
global.checkFaceInPhoto = checkFaceInPhoto;
global.isMemeOrFake = isMemeOrFake;
global.detectGenderFacePlusPlus = detectGenderFacePlusPlus;
global.faceDetector = faceDetector;
global.faceDetectorBuffer = faceDetectorBuffer;

module.exports = photosRouter;